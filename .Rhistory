library(DescTools)
library(glmnet)
ins_t_raw = readr::read_csv('./insurance_t.csv')
ins_t = data.frame(ins_t_raw)
categoricals = c('DDA', 'DIRDEP', 'NSF', 'TELLER', 'SAV',
'ATM', 'CD', 'IRA', 'INV', 'MM', 'CC',
'SDB', 'INAREA', 'INS', 'BRANCH')
ins_t = ins_t %>%
mutate(across(categoricals,
as.factor))
ins_t
missing = ins_t %>%
summarize(across(everything(),
~sum(is.na(.)))) %>%
t() %>%
as.data.frame() %>%
mutate(n_missing = V1) %>%
dplyr::select(!V1) %>%
filter(n_missing > 0)
missing_cols = missing %>% rownames()
# missing columns subsets for numeric and categorical data, respectively
missing_num = setdiff(missing_cols, categoricals)
missing_fctr = intersect(missing_cols, categoricals)
ins_t = ins_t %>%
# # new missingness indicator column for each column with missingness
# mutate(
#   across(
#     .cols = all_of(missing_cols),
#     .fns = ~ .x %>%
#       is.na() %>%
#       as.numeric() %>%
#       as.factor(),
#     .names = '{col}_is_imputed'
#   )
# ) %>%
# Continuous variables: median imputation
mutate(
across(all_of(missing_num),
~ replace_na(.x, median(.x, na.rm = T))
)
) %>%
# Categorical variables: mode imputation
mutate(
across(all_of(missing_fctr),
~ replace_na(.x, Mode(.x, na.rm = T)))
)
head(ins_t, n=5)
knitr::opts_chunk$set(echo = TRUE)
summary(gam1)
library(tidyverse)
library(earth)         # MARS
library(segmented)     # piecewise (segmented) regression
library(splines)       # regression splines (bs, ns) - kept for reference
library(mgcv)          # smoothing splines via GAM
library(caret)         # data splitting / utilities
library(Metrics)       # rmse, mse helpers (plus we'll compute R2 manually)
library(DescTools)
library(glmnet)
#Cleaning, imputation
ins_t_raw = readr::read_csv('./insurance_t.csv')
ins_t = data.frame(ins_t_raw)
categoricals = c('DDA', 'DIRDEP', 'NSF', 'TELLER', 'SAV',
'ATM', 'CD', 'IRA', 'INV', 'MM', 'CC',
'SDB', 'INAREA', 'INS', 'BRANCH')
ins_t = ins_t %>%
mutate(across(categoricals,
as.factor))
ins_t
missing = ins_t %>%
summarize(across(everything(),
~sum(is.na(.)))) %>%
t() %>%
as.data.frame() %>%
mutate(n_missing = V1) %>%
dplyr::select(!V1) %>%
filter(n_missing > 0)
missing_cols = missing %>% rownames()
# missing columns subsets for numeric and categorical data, respectively
missing_num = setdiff(missing_cols, categoricals)
missing_fctr = intersect(missing_cols, categoricals)
ins_t = ins_t %>%
# # new missingness indicator column for each column with missingness
# mutate(
#   across(
#     .cols = all_of(missing_cols),
#     .fns = ~ .x %>%
#       is.na() %>%
#       as.numeric() %>%
#       as.factor(),
#     .names = '{col}_is_imputed'
#   )
# ) %>%
# Continuous variables: median imputation
mutate(
across(all_of(missing_num),
~ replace_na(.x, median(.x, na.rm = T))
)
) %>%
# Categorical variables: mode imputation
mutate(
across(all_of(missing_fctr),
~ replace_na(.x, Mode(.x, na.rm = T)))
)
head(ins_t, n=5)
full.model = glm(INS~., data = ins_t, family = "binomial"(link = "logit"))
test = car::Anova(back.model, test = 'LR', type = 'III', singular.ok =TRUE)
full.model = glm(INS~., data = ins_t, family = "binomial"(link = "logit"))
test = car::Anova(full.model, test = 'LR', type = 'III', singular.ok =TRUE)
test[rownames(test) %in% bin_vars_back_elim,] %>% arrange (`Pr(>Chisq)`)
test[rownames(test) %in% colnames(ins_t),] %>% arrange (`Pr(>Chisq)`)
test[rownames(test) %in% colnames(ins_t),] %>% arrange (`Pr(>Chisq)`) %>% head(n=16)
ACCTAGE_gam = mgcv::gam(INS~ S(ACCTAGE, k=9), data = ins_t, method = "REML", family = binomial(link="logit"))
ACCTAGE_gam = mgcv::gam(INS~ s(ACCTAGE, k=9), data = ins_t, method = "REML", family = binomial(link="logit"))
summary(ACCTAGE_gam)
DDABAL_gam = mgcv::gam(INS~ s(DDABAL, k=9), data = ins_t, method = "REML", family = binomial(link="logit"))
summary(DDABAL_gam) #EDF = 2 -> nonlinear
DEPAMT_gam = mgcv::gam(INS~ s(DEPAMT, k=9), data = ins_t, method = "REML", family = binomial(link="logit"))
summary(DEPAMT_gam) #EDF = 5ish -> nonlinear
CHECKS_gam = mgcv::gam(INS~ s(CHECKS, k=9), data = ins_t, method = "REML", family = binomial(link="logit"))
summary(CHECKS_gam) #EDF = 7ish -> nonlinear
PHONE_gam = mgcv::gam(INS~ s(PHONE, k=9), data = ins_t, method = "REML", family = binomial(link="logit"))
summary(PHONE_gam) #EDF = 4ish -> nonlinear
length(setdiff(colnames(ins_t), categoricals))
setdiff(colnames(ins_t), categoricals)
univariate_gams = lapply(predictor_list, function(var_name){
formula_str = paste("INS ~ s(", var_name, ")")
formula_obj = as.formula(formula_str)
mgcv::gam(formula_obj, data = ins_t, method = "REML", family = binomial(link="logit"))
})
predictor_list = setdiff(colnames(ins_t), categoricals)
univariate_gams = lapply(predictor_list, function(var_name){
formula_str = paste("INS ~ s(", var_name, ")")
formula_obj = as.formula(formula_str)
mgcv::gam(formula_obj, data = ins_t, method = "REML", family = binomial(link="logit"))
})
predictor_list
test[rownames(test) %in% colnames(ins_t),] %>% arrange (`Pr(>Chisq)`) %>% head(n=16)
sig_lin_vars = test[rownames(test) %in% colnames(ins_t),] %>% arrange (`Pr(>Chisq)`) %>% head(n=16)
rownames(sig_lin_vars)
sig_lin_tbl = test[rownames(test) %in% colnames(ins_t),] %>% arrange (`Pr(>Chisq)`) %>% head(n=16)
sig_lin_vars= rownames(sig_lin_tbl)
sig_lin_vars
predictor_list = setdiff(colnames(ins_t), categoricals)
predictor_list2 = setdiff(predictor_list, sig_lin_vars)
predictor_list2
length(predictor_list)
length(predictor_list2)
gam_vars = setdiff(predictor_list, sig_lin_vars)
for (j in gam_vars){
print(paste(j, ':', length(unique(ins_t[[j]]))))
}
gam_vars
gam_vars2 = gam_vars - "MMCRED" - "CCPURC"
gam_vars2 = setdiff(gam_vars, c("MMCRED","CCPURC"))
gam_vars2
univariate_gams = lapply(c("MMCRED", "CCPURC"), function(var_name){
formula_str = paste("INS ~ s(", var_name, ", k=5)")
formula_obj = as.formula(formula_str)
mgcv::gam(formula_obj, data = ins_t, method = "REML", family = binomial(link="logit"))
})
univariate_gams
MMCRED_CCPURC_gams = lapply(c("MMCRED", "CCPURC"), function(var_name){
formula_str = paste("INS ~ s(", var_name, ", k=5)")
formula_obj = as.formula(formula_str)
mgcv::gam(formula_obj, data = ins_t, method = "REML", family = binomial(link="logit"))
})
MMCRED_CCPURC_gams
univariate_gams = lapply(gam_vars2, function(var_name){
formula_str = paste("INS ~ s(", var_name, ")")
formula_obj = as.formula(formula_str)
mgcv::gam(formula_obj, data = ins_t, method = "REML", family = binomial(link="logit"))
})
univariate_gams = lapply(gam_vars2, function(var_name){
formula_str = paste("INS ~ s(", var_name, ")")
formula_obj = as.formula(formula_str)
summary(mgcv::gam(formula_obj, data = ins_t, method = "REML", family = binomial(link="logit")))
})
univariate_gams
ACCTAGE_gam = mgcv::gam(INS~ s(ACCTAGE, k=9), data = ins_t, method = "REML", family = binomial(link="logit"))
summary(ACCTAGE_gam)
names(univariate_gams) = gam_vars2
univariate_gams
others_edf_table <- sapply(univariate_gams, function(model) {
# The EDF is in the summary's smooth-table
summary(model)$s.table[1, "edf"]
})
univariate_gams
# 3. Use sapply() to loop over your new list and extract the EDF
edf_table <- sapply(univariate_gams, function(model) {
# Check if the element is actually a 'gam' model object
if (inherits(model, "gam")) {
# If yes, extract the EDF
return(summary(model)$s.table[1, "edf"])
} else {
# If no (it's probably an error), return NA
return(NA_real_)
}
})
edf_table <- sapply(univariate_gams, function(model) {
# Check if the element is actually a 'gam' model object
if (inherits(model, "gam")) {
# If yes, extract the EDF
return(summary(model)$s.table[1, "edf"])
} else {
# If no (it's probably an error), return NA
return(NA_real_)
}
})
# 4. Print the result
# This will now print the EDF or NA for each variable
print(edf_table)
univariate_gams = lapply(gam_vars2, function(var_name){
formula_str = paste("INS ~ s(", var_name, ")")
formula_obj = as.formula(formula_str)
pen.edf(mgcv::gam(formula_obj, data = ins_t, method = "REML", family = binomial(link="logit")))
})
names(univariate_gams) = gam_vars2
univariate_gams
univariate_gams > 1.20
univariate_gams[univariate_gams > 1.20]
names(univariate_gams[univariate_gams > 1.20])
MMCRED_CCPURC_gams = lapply(c("MMCRED", "CCPURC"), function(var_name){
formula_str = paste("INS ~ s(", var_name, ", k=5)")
formula_obj = as.formula(formula_str)
pen.edf(mgcv::gam(formula_obj, data = ins_t, method = "REML", family = binomial(link="logit")))
})
MMCRED_CCPURC_gams
nonlinear_other_vars
names(univariate_gams) = gam_vars2
nonlinear_other_vars = names(univariate_gams[univariate_gams > 1.20])
nonlinear_other_vars
c(non_linear_other_vars, "MMCRED", "CCPURC")
nonlinear_other_vars = names(univariate_gams[univariate_gams > 1.20])
c(non_linear_other_vars, "MMCRED", "CCPURC")
c(nonlinear_other_vars, "MMCRED", "CCPURC")
c(nonlinear_other_vars, "MMCRED", "CCPURC")
sig_lin_vars
gam2 <- mgcv::gam(INS ~ s(DEP) + s(DEPAMT) + s(NFSAMT) + s(POS) + s(POSAMT) + s(IRABAL) +
s(INVBAL) + s(MMBAL) + s(CRSCORE) + s(MMCRED, k=5) + s(CCPURC, k=5) +
SAVBAL + SAV + CD + DDABAL + DDA + BRANCH + ATMAMT + CC + TELLER +
MM + INV + CDBAL + IRA + PHONE + CHECKS + ACCTAGE, method="REML", family = binomial(link="logit"))
gam2 <- mgcv::gam(INS ~ s(DEP) + s(DEPAMT) + s(NFSAMT) + s(POS) + s(POSAMT) + s(IRABAL) +
s(INVBAL) + s(MMBAL) + s(CRSCORE) + s(MMCRED, k=5) + s(CCPURC, k=5) +
SAVBAL + SAV + CD + DDABAL + DDA + BRANCH + ATMAMT + CC + TELLER +
MM + INV + CDBAL + IRA + PHONE + CHECKS + ACCTAGE, data = ins_t, method="REML", family = binomial(link="logit"))
gam2 <- mgcv::gam(INS ~ s(DEP) + s(DEPAMT) + s(NSFAMT) + s(POS) + s(POSAMT) + s(IRABAL) +
s(INVBAL) + s(MMBAL) + s(CRSCORE) + s(MMCRED, k=5) + s(CCPURC, k=5) +
SAVBAL + SAV + CD + DDABAL + DDA + BRANCH + ATMAMT + CC + TELLER +
MM + INV + CDBAL + IRA + PHONE + CHECKS + ACCTAGE, data = ins_t, method="REML", family = binomial(link="logit"))
summary(gam2)
num_preds = setdiff(colnames(ins_t), categoricals)
for (j in num_preds){
print(paste(j, ':', length(unique(ins_t[[j]]))))
}
univariate_gams = lapply(gam_vars2, function(var_name){
formula_str = paste("INS ~ s(", var_name, ")")
formula_obj = as.formula(formula_str)
pen.edf(mgcv::gam(formula_obj, data = ins_t, method = "REML", family = binomial(link="logit")))
})
names(univariate_gams) = gam_vars2
nonlinear_other_vars = names(univariate_gams[univariate_gams > 1.20])
nonlinear_other_vars
summary(gam2)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(earth)         # MARS
library(segmented)     # piecewise (segmented) regression
library(splines)       # regression splines (bs, ns) - kept for reference
library(mgcv)          # smoothing splines via GAM
library(caret)         # data splitting / utilities
library(Metrics)       # rmse, mse helpers (plus we'll compute R2 manually)
library(DescTools)
library(glmnet)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(earth)         # MARS
library(segmented)     # piecewise (segmented) regression
library(splines)       # regression splines (bs, ns) - kept for reference
library(mgcv)          # smoothing splines via GAM
library(caret)         # data splitting / utilities
library(Metrics)       # rmse, mse helpers (plus we'll compute R2 manually)
library(DescTools)
library(glmnet)
ins_t_raw = readr::read_csv('./insurance_t.csv')
ins_t = data.frame(ins_t_raw)
categoricals = c('DDA', 'DIRDEP', 'NSF', 'TELLER', 'SAV',
'ATM', 'CD', 'IRA', 'INV', 'MM', 'CC',
'SDB', 'INAREA', 'INS', 'BRANCH')
ins_t = ins_t %>%
mutate(across(categoricals,
as.factor))
ins_t
missing = ins_t %>%
summarize(across(everything(),
~sum(is.na(.)))) %>%
t() %>%
as.data.frame() %>%
mutate(n_missing = V1) %>%
dplyr::select(!V1) %>%
filter(n_missing > 0)
missing_cols = missing %>% rownames()
# missing columns subsets for numeric and categorical data, respectively
missing_num = setdiff(missing_cols, categoricals)
missing_fctr = intersect(missing_cols, categoricals)
ins_t = ins_t %>%
# # new missingness indicator column for each column with missingness
# mutate(
#   across(
#     .cols = all_of(missing_cols),
#     .fns = ~ .x %>%
#       is.na() %>%
#       as.numeric() %>%
#       as.factor(),
#     .names = '{col}_is_imputed'
#   )
# ) %>%
# Continuous variables: median imputation
mutate(
across(all_of(missing_num),
~ replace_na(.x, median(.x, na.rm = T))
)
) %>%
# Categorical variables: mode imputation
mutate(
across(all_of(missing_fctr),
~ replace_na(.x, Mode(.x, na.rm = T)))
)
head(ins_t, n=5)
#Standardize
ins_t_s <- ins_t %>%
mutate(across(where(is.numeric), scale))
#Perform Lasso regression on training data
x_train <- model.matrix(INS ~ ., ins_t_s)[, -1]
y_train <- ins_t_s$INS
set.seed(123)
cv_lasso <- cv.glmnet(x_train, y_train, alpha = 1, nfolds = 10, family = binomial(link=logit))
#get coefficients
best_lambda = cv_lasso$lambda.min
coefs = as.matrix(coef(cv_lasso, s = best_lambda))
nonzero = coefs[coefs != 0, , drop = FALSE]
#Nonzero coefficents:
#Numeric:
# ACCTAGE, DDABAL, DEPAMT, CHECKS, PHONE, TELLER, SAVBAL, ATMAMT, POS, POSAMT, CDBAL, IRABAL, INVBAL, MMCRED, HMVAL
#Categorical:
# DDA, DIRDEP, SAV, ATM, CD, IRA, INV, MM, CC, SDB, BRANCH
gam1 <- mgcv::gam(INS ~ s(ACCTAGE, k=5) + DDA + s(DDABAL, k=5) + s(DEPAMT, k=5) + s(CHECKS, k=5)+
DIRDEP + s(PHONE, k=5) + TELLER + SAV + s(SAVBAL, k=5) + ATM +
s(ATMAMT, k=5) + s(POS, k=5) + s(POSAMT, k=5) + CD + s(CDBAL, k=9) + IRA +
s(IRABAL, k=5) + INV + MM + s(MMCRED, k=5) + CC + SDB +
s(HMVAL, k=5) + BRANCH, data=ins_t, method="REML", family = binomial(link="logit"))
summary(gam1)
m1_pred = predict(gam1, ins_t, type = "response")
library(ROCit)
m1_roc <- rocit(m1_pred, ins_t$INS)
m1_roc
m1_roc$AUC
full.model = glm(INS~., data = ins_t, family = "binomial"(link = "logit"))
test = car::Anova(full.model, test = 'LR', type = 'III', singular.ok =TRUE)
sig_lin_tbl = test[rownames(test) %in% colnames(ins_t),] %>% arrange (`Pr(>Chisq)`) %>% head(n=16)
sig_lin_vars= rownames(sig_lin_tbl)
#For numeric variables, fit a GAM and see which ones are nonlinearly related
#Get all our numerical predictors
num_preds = setdiff(colnames(ins_t), categoricals)
#Get any that were not significant in our LRT (meaning they might be nonlinear)
gam_vars = setdiff(predictor_list, sig_lin_vars)
full.model = glm(INS~., data = ins_t, family = "binomial"(link = "logit"))
test = car::Anova(full.model, test = 'LR', type = 'III', singular.ok =TRUE)
sig_lin_tbl = test[rownames(test) %in% colnames(ins_t),] %>% arrange (`Pr(>Chisq)`) %>% head(n=16)
sig_lin_vars= rownames(sig_lin_tbl)
#For numeric variables, fit a GAM and see which ones are nonlinearly related
#Get all our numerical predictors
num_preds = setdiff(colnames(ins_t), categoricals)
#Get any that were not significant in our LRT (meaning they might be nonlinear)
gam_vars = setdiff(num_preds, sig_lin_vars)
for (j in gam_vars){
print(paste(j, ':', length(unique(ins_t[[j]]))))
}
#MMCRED and CCPURC have a maximum degree (k) of 5 since they have 5 levels
MMCRED_CCPURC_gams = lapply(c("MMCRED", "CCPURC"), function(var_name){
formula_str = paste("INS ~ s(", var_name, ", k=5)")
formula_obj = as.formula(formula_str)
pen.edf(mgcv::gam(formula_obj, data = ins_t, method = "REML", family = binomial(link="logit")))
})
MMCRED_CCPURC_gams
#Both MMCRED and CCPURC are nonlinear!
#Get the rest of the variables besides those 2
gam_vars2 = setdiff(gam_vars, c("MMCRED","CCPURC"))
gam_vars2
#Repeat for the rest using the default degree
univariate_gams = lapply(gam_vars2, function(var_name){
formula_str = paste("INS ~ s(", var_name, ")")
formula_obj = as.formula(formula_str)
pen.edf(mgcv::gam(formula_obj, data = ins_t, method = "REML", family = binomial(link="logit")))
})
names(univariate_gams) = gam_vars2
nonlinear_other_vars = names(univariate_gams[univariate_gams > 1.20])
#"DEP"     "DEPAMT"  "NSFAMT"  "POS"     "POSAMT"  "IRABAL"  "INVBAL"  "MMBAL"   "CRSCORE" are nonlinear
#So all in all we have the following variables with nonlinear relationship to outcome that MAY be significant:
c(nonlinear_other_vars, "MMCRED", "CCPURC")
#"DEP"     "DEPAMT"  "NSFAMT"  "POS"     "POSAMT"  "IRABAL"  "INVBAL"  "MMBAL"   "CRSCORE" "MMCRED"  "CCPURC"
# Where MMCRED and CCPURC require k=5 or less
#Combine into a modified full model w/ significant linear predictors from before plus splines fitted to these:
gam2 <- mgcv::gam(INS ~ s(DEP) + s(DEPAMT) + s(NSFAMT) + s(POS) + s(POSAMT) + s(IRABAL) +
s(INVBAL) + s(MMBAL) + s(CRSCORE) + s(MMCRED, k=5) + s(CCPURC, k=5) +
SAVBAL + SAV + CD + DDABAL + DDA + BRANCH + ATMAMT + CC + TELLER +
MM + INV + CDBAL + IRA + PHONE + CHECKS + ACCTAGE, data = ins_t, method="REML", family = binomial(link="logit"))
summary(gam2)
m2_pred = predict(gam2, ins_t, type = "response")
library(ROCit)
m2_roc <- rocit(m2_pred, ins_t$INS)
m2_roc$AUC
m2_roc$AUC
m1_roc$AUC
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(earth)         # MARS
library(segmented)     # piecewise (segmented) regression
library(splines)       # regression splines (bs, ns) - kept for reference
library(mgcv)          # smoothing splines via GAM
library(caret)         # data splitting / utilities
library(Metrics)       # rmse, mse helpers (plus we'll compute R2 manually)
library(DescTools)
library(glmnet)
ins_t_raw = readr::read_csv('./insurance_t.csv')
ins_t = data.frame(ins_t_raw)
nrow(ins_t)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(earth)         # MARS
library(segmented)     # piecewise (segmented) regression
library(splines)       # regression splines (bs, ns) - kept for reference
library(mgcv)          # smoothing splines via GAM
library(caret)         # data splitting / utilities
library(Metrics)       # rmse, mse helpers (plus we'll compute R2 manually)
library(DescTools)
library(glmnet)
ins_t_raw = readr::read_csv('./insurance_t.csv')
ins_t = data.frame(ins_t_raw)
nrow(ins_t)
categoricals = c('DDA', 'DIRDEP', 'NSF', 'TELLER', 'SAV',
'ATM', 'CD', 'IRA', 'INV', 'MM', 'CC',
'SDB', 'INAREA', 'INS', 'BRANCH')
ins_t = ins_t %>%
mutate(across(categoricals,
as.factor))
ins_t
missing = ins_t %>%
summarize(across(everything(),
~sum(is.na(.)))) %>%
t() %>%
as.data.frame() %>%
mutate(n_missing = V1) %>%
dplyr::select(!V1) %>%
filter(n_missing > 0)
missing_cols = missing %>% rownames()
# missing columns subsets for numeric and categorical data, respectively
missing_num = setdiff(missing_cols, categoricals)
missing_fctr = intersect(missing_cols, categoricals)
ins_t = ins_t %>%
# # new missingness indicator column for each column with missingness
# mutate(
#   across(
#     .cols = all_of(missing_cols),
#     .fns = ~ .x %>%
#       is.na() %>%
#       as.numeric() %>%
#       as.factor(),
#     .names = '{col}_is_imputed'
#   )
# ) %>%
# Continuous variables: median imputation
mutate(
across(all_of(missing_num),
~ replace_na(.x, median(.x, na.rm = T))
)
) %>%
# Categorical variables: mode imputation
mutate(
across(all_of(missing_fctr),
~ replace_na(.x, Mode(.x, na.rm = T)))
)
head(ins_t, n=5)
#Standardize
ins_t_s <- ins_t %>%
mutate(across(where(is.numeric), scale))
#Perform Lasso regression on training data
x_train <- model.matrix(INS ~ ., ins_t_s)[, -1]
y_train <- ins_t_s$INS
set.seed(123)
cv_lasso <- cv.glmnet(x_train, y_train, alpha = 1, nfolds = 10, family = binomial(link=logit))
#get coefficients
best_lambda = cv_lasso$lambda.min
coefs = as.matrix(coef(cv_lasso, s = best_lambda))
nonzero = coefs[coefs != 0, , drop = FALSE]
#Nonzero coefficents:
#Numeric:
# ACCTAGE, DDABAL, DEPAMT, CHECKS, PHONE, TELLER, SAVBAL, ATMAMT, POS, POSAMT, CDBAL, IRABAL, INVBAL, MMCRED, HMVAL
#Categorical:
# DDA, DIRDEP, SAV, ATM, CD, IRA, INV, MM, CC, SDB, BRANCH
gam1 <- mgcv::gam(INS ~ s(ACCTAGE, k=5) + DDA + s(DDABAL, k=5) + s(DEPAMT, k=5) + s(CHECKS, k=5)+
DIRDEP + s(PHONE, k=5) + TELLER + SAV + s(SAVBAL, k=5) + ATM +
s(ATMAMT, k=5) + s(POS, k=5) + s(POSAMT, k=5) + CD + s(CDBAL, k=9) + IRA +
s(IRABAL, k=5) + INV + MM + s(MMCRED, k=5) + CC + SDB +
s(HMVAL, k=5) + BRANCH, data=ins_t, method="REML", family = binomial(link="logit"))
summary(gam1)
m1_pred = predict(gam1, ins_t, type = "response")
library(ROCit)
m1_roc <- rocit(m1_pred, ins_t$INS)
m1_roc$AUC #0.79- not bad!
plot(m1_roc)
title("ROC Curve")
plot(m1_roc)
